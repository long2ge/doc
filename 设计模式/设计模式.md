# 设计模式
## 面向对象六大设计原则
1. 单一职责原则  
    定义：就一个类而言，应该仅有一个引起它变化的原因。  
    理解：一个类做一件事。 
2. 里氏替换原则  
    定义：所有应用其基类的地方，必须都能透明的使用其子类的对象。 
    理解：声明使用抽象类或者接口。  
3. 依赖倒置原则  
    定义：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。  
    理解：高层模块定义接口，低层模块负责实现。  
4. 接口隔离原则  
    定义：客户端不应该依赖它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上。  
    理解：尽量将接口设计的小，方法少，职能单一。  
5. 迪米特法则   
    定义：最少知识原则,也就是说,一个对象应当对其他对象尽可能少的了解。  
    理解：尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，
         那么这两个对象就不应当发生任何的直接作用，
         如果其中一个对象需要另一个对象的某个方法的时候，我们可以通过第三者来转发这个调用。
6. 开闭原则  
    定义：对于扩展是开放的，对于修改是封闭的。  
    理解：对扩展开放，对修改关闭。  

## 设计模式的六大原则
1. 开闭原则
2. 里氏代换原则
3. 依赖倒转原则
4. 接口隔离原则
5. 迪米特法则
6. 合成复用原则。尽量使用合成/聚合的方式，而不是使用继承。


## 创建型模式
工厂模式（Factory Pattern）
抽象工厂模式（Abstract Factory Pattern）
单例模式（Singleton Pattern）
建造者模式（Builder Pattern）
原型模式（Prototype Pattern）

## 结构型模式
适配器模式（Adapter Pattern）
桥接模式（Bridge Pattern）
过滤器模式（Filter、Criteria Pattern）
组合模式（Composite Pattern）
装饰器模式（Decorator Pattern）
### 外观模式（Facade Pattern）
    外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
    
    1， 厨师就相当于外观，我们想要吃什么东西（比如糖醋排骨）只要问厨师（调用外观）点就行了道，
    厨师（外观）会做好了给我们，而在这个过程中，我们完全不必知内道糖醋排骨的制作流程，
    从而减少客户端调用和各个处理类之间的耦合度
    
    2， 为一个复杂的模块或子系统提供一个供外界访问的接口
享元模式（Flyweight Pattern）
### 代理模式（Proxy Pattern）
    代理（Proxy）模式：
    为某对象提供一种代理以控制对该对象的访问。
    即客户端通过代理间接地访问该对象，
    从而限制、增强或修改该对象的一些特性。
    
    1， 代理模式只是多了一个环节在中间进行传递和过滤，但是真正来做操作的还是后面的接口
    2， 代理模式的关键词是：控制，保护
    3， 代理模式的关键词是保护，也就是说代理模式不会对功能进行增益扩充，只是要对接口进行保护。
    
    
    (1) 远程代理 为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率。
    
    (2) 虚拟代理 通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。
    
    (3) 缓冲代理 为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。
    
    (4) 保护代理 可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。
    
    延迟加载的核心思想是：如果当前并没有使用这个组件，则不需要真正地初始化它，使用一个代理对象替代它的原有的位置，只要在真正需要的时候才对它进行加载。
    
    代理模式分为静态代理和动态代理（反射）

## 行为型模式
    这些设计模式特别关注对象之间的通信。
    
    
    行为型模式分为类行为模式和对象行为模式，
    前者采用继承机制来在类间分派行为，
    后者采用组合或聚合在对象间分配行为。
    由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”
### 责任链模式（Chain of Responsibility Pattern）
    职责链（Chain of Responsibility）模式：
    把请求从链中的一个对象传到下一个对象，
    直到请求被响应为止。通过这种方式去除对象之间的耦合。
    1.多个对象可以处理同一个请求，但具体由哪个对象处理则在运行时动态决定。
    2. 在请求处理者不明确的情况下向对个对象中的一个提交一个请求。
    3. 需要动态处理一组对象处理请求。
    

### 命令模式（Command Pattern）
    命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
    三个角色，
    Receiver接受者角色：该角色就是干活的角色，命令传递到这里是应该被执行的
    Command命令角色：需要执行的所有命令都在这里声明
    Invoker调用者角色：接收到命令，并执行命令
    
    聊天室功能，
    命令模式仅仅是为了松耦合。如果调解人的数量变大，此时易维护性就变差了。
    
    0, 命令模式为系统中不同的对象提供中性化的交流媒介
    
    1, 使用命令模式作为“回调（CallBack）”在面向对象系统中的代替。“CallBack”
    讲的便是现将一个函数登记上，然后在以后调用此函数。
    
    2, 需要在不同的时间制定请求、将请求排队。
    一个命令对象和原先的请求发出者可以有不同的生命周期。
    换言之，原先的请求发出者可能已经不存在了，而命令对象本身仍然是活动的。
    这时命令的接受者可以是在本地，也可以在网络的另外一个地址。
    命令对象可以在序列化之后传送到另外一台机器上去。 
    
    
    3, 系统需要支持命令的撤销。
    命令对象可以把状态存储起来，等到客户端需要撤销命令所产生的效果时，
    可以调用undo()方法，把命令所产生的效果撤销掉。命令对象还可以提供redo()方法，
    以供客户端需要时再重新实施命令效果。
    
    4, 如果要将系统中所有的数据更新到日志里。
    以便在系统崩溃时，可以根据日志读回所有的数据更新命令。
    重新调用Execute()方法一条一条执行这些命令，
    从而恢复系统在崩溃前所做的数据更新。
    
    5, 命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收
    者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。
    
    
    6, 命令队列与我们常说的“批处理”有点类似。
    批处理，顾名思义，可以对一组对象（命令）进行批量处理，
    当一个发送者发送请求后，将有一系列接收者对请求作出响应，
    命令队列可以用于设计批处理应用程序，如果请求接收者的接收次序没有严格的先后次序，
    我们还可以使用多线程技术来并发调用命令对象的execute()方法，从而提高程序的执行效率。
    
    
    Command模式通常可应用到以下场景： 
      1 Multi-level undo（多级undo操作） 
        如果系统需要实现多级回退操作，这时如果所有用户的操作都以command对象的形式实现，系统可以简 
    
        单地用stack来保存最近执行的命令，如果用户需要执行undo操作，系统只需简单地popup一个最近的 
    
        command对象然后执行它的undo()方法既可。 
    
      2 Transactional behavior（原子事务行为） 
        借助command模式，可以简单地实现一个具有原子事务的行为。当一个事务失败时，往往需要回退到执 
    
        行前的状态，可以借助command对象保存这种状态，简单地处理回退操作。 
    
    
      3 Progress bars（状态条） 
        假如系统需要按顺序执行一系列的命令操作，如果每个command对象都提供一个 
    
        getEstimatedDuration()方法，那么系统可以简单地评估执行状态并显示出合适的状态条。 
    
    
      4 Wizards（导航） 
        通常一个使用多个wizard页面来共同完成一个简单动作。一个自然的方法是使用一个command对象来封 
    
        装wizard过程，该command对象在第一个wizard页面显示时被创建，每个wizard页面接收用户输入并设 
    
        置到该command对象中，当最后一个wizard页面用户按下“Finish”按钮时，可以简单地触发一个事件 
    
        调用execute()方法执行整个动作。通过这种方法，command类不包含任何跟用户界面有关的代码，可以 
    
        分离用户界面与具体的处理逻辑。 
    
    
      5 GUI buttons and menu items（GUI按钮与菜单条等等） 
        Swing系统里，用户可以通过工具条按钮，菜单按钮执行命令，可以用command对象来封装命令的执行。 
    
    
      6 Thread pools（线程池） 
        通常一个典型的线程池实现类可能有一个名为addTask()的public方法，用来添加一项工作任务到任务 
    
        队列中。该任务队列中的所有任务可以用command对象来封装，通常这些command对象会实现一个通用的 
    
        接口比如java.lang.Runnable。 
    
    
      7 Macro recording（宏纪录） 
        可以用command对象来封装用户的一个操作，这样系统可以简单通过队列保存一系列的command对象的状 
    
        态就可以记录用户的连续操作。这样通过执行队列中的command对象，就可以完成"Play back"操作了。 
    
    
      8 Networking 
        通过网络发送command命令到其他机器上运行。 
    
    
      9 Parallel Processing（并发处理） 
        当一个调用共享某个资源并被多个线程并发处理时。 
    	
    	需要在不同的时间制定请求、将请求排队。一个命令对象和原先的请求发出者可以有不同的生命周期。换言之，原先的请求发出者可能已经不存在了，而命令对象本身仍然是活动的。这时命令的接受者可以是在本地，也可以在网络的另外一个地址。命令对象可以在序列化之后传送到另外一台机器上去。 
    
    系统需要支持命令的撤销。命令对象可以把状态存储起来，等到客户端需要撤销命令所产生的效果时，可以调用undo()方法，把命令所产生的效果撤销掉。命令对象还可以提供redo()方法，以供客户端需要时再重新实施命令效果。
    
    如果要将系统中所有的数据更新到日志里。以便在系统崩溃时，可以根据日志读回所有的数据更新命令。
    重新调用Execute()方法一条一条执行这些命令，从而恢复系统在崩溃前所做的数据更新。

### 解释器模式（Interpreter Pattern）
    解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。
    对于一些固定文法构建一个解释句子的解释器
    1，用户动态解析规则，包括计算公式，sql解析，
    2，两个概念，编译原理里面的非终结符和终结符（不能拆分的最小元素）
    
    在数学的计算公式里面
    
    终结符是数字，因为数字除了需要赋值外，不需要做任何处理，
    所有运算元素都对应一个具体的业务参数，这是语法中最小的单元逻辑，不可再拆分
    
    非终结符是运算符号，因为每个运算符号都要对应处理单元，
    否则公式无法运行，运算符号也叫做非终结符号
    
    解析 把数字放到终结符对象，运算符号放到非终结符对象。
    解析的工作完成了，我们还需要把安排运行的先后顺序
### 迭代器模式（Iterator Pattern）
    迭代器（Iterator）模式：
    1， 提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
    2， 为遍历不同的集合结构提供一个统一的接口
### 中介者模式（Mediator Pattern）
    中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，
    降低系统中对象间的耦合度，使原有对象之间不必相互了解。
    
    是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护
    1,又代码通信方法从网状结构分离为星型结构
### 备忘录模式（Memento Pattern）
    备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
    1, 浏览器回退：浏览器一般有浏览记录，当我们在一个网页上点击几次链接之后，可在左上角点击左箭头回退到上一次的页面，然后也可以点击右箭头重新回到当前页面
    
    2, 数据库备份与还原：一般的数据库都支持备份与还原操作，备份即将当前已有的数据或者记录保留，还原即将已经保留的数据恢复到对应的表中
    
    3, 编辑器撤销与重做：在编辑器上编辑文字，写错时可以按快捷键 Ctrl + z 撤销，撤销后可以按 Ctrl + y 重做
    
    4, 虚拟机生成快照与恢复：虚拟机可以生成一个快照，当虚拟机发生错误时可以恢复到快照的样子
    
    5, Git版本管理：Git是最常见的版本管理软件，每提交一个新版本，实际上Git就会把它们自动串成一条时间线，每个版本都有一个版本号，使用 git reset --hard 版本号 即可回到指定的版本，让代码时空穿梭回到过去某个历史时刻
    
    6, 棋牌游戏悔棋：在棋牌游戏中，有时下快了可以悔棋，回退到上一步重新下
    
    1.Originator(发起人)：负责创建一个备忘录Memento，用以记录当前时刻自身的内部状态
    2, Memento(备忘录)：负责存储Originator对象的内部状态
    3, Caretaker(管理者):负责记录备忘录Memento的历史状态

### 观察者模式（Observer Pattern）
    观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
    1， 当一个抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。
    2， 当对一个对象的改变需要同时改变其它对象，而不知道具体有多少对象有待改变。
    3， 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧密耦合的。
    4， 其实观察者模式同前面讲过的桥梁、策略有着共同的使用环境：将变化独立封装起来，以达到最大的重用和解耦。观察者与后两者不同的地方在于，
    观察者模式中的目标和观察者的变化不是独立的，而是有着某些联系。
### 状态模式（State Pattern）
    状态（State）模式：- 避免使用多重条件判断 - ( 针对不同的状态有不同的行为 )
    允许一个对象在其内部状态发生改变时改变其行为能力。
    1， 允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。
    2，用户没有登录，会先自动跳转到登录注册界面，如果已经登录，当然就可以直接评论或者转发了。
    这里我们可以看到，我们用户的行为是由当前是否登录这个状态来决定的，这就是典型的状态模式情景。
    3， QQ的不同状态可以用状态模式来处理，包括离线，登录中，在线和忙碌。
    4， 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。
    5， 在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。
    6，状态模式不同状态下做的事情不同，而策略模式做的都是同一件事，
    例如聚合支付平台，有支付宝、微信支付、银联支付，虽然策略不同，
    但最终做的事情都是支付，也就是说他们之间是可替换的。
    反观状态模式，各个状态的同一方法做的是不同的事，不能互相替换。

### 空对象模式（Null Object Pattern）
    空对象模式
    在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。Null 对象不是检查空值，而是反应一个不做任何动作的关系。这样的 Null 对象也可以在数据不可用的时候提供默认的行为。

### 策略模式（Strategy Pattern）
    策略（Strategy）模式：- 避免使用多重条件判断（针对同一个行为,例如都是支付）
    定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，
    且算法的改变不会影响使用算法的客户。
    1， 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换
    2，日志记录到数据库和日志记录到文件当作两种记录日志的策略
    3， 如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。
    4，外出旅游是坐火车，高铁，还是飞机。
    5,一条鱼根据烹饪方式不同可以做出很多道菜，可以清蒸、红烧、炭烤等，每种烹饪方式的过程都不大相同。

### 模板模式（Template Pattern）
    模板方法（Template Method）模式：-- 流程不变，每一步的操作都不同
    定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，
    使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
    1,杀一条鱼的顺序，杀鱼->去鱼鳞->清内脏，每一步具体操作都可能不一样，
    比如杀鱼可以用刀背、擀面杖等，鱼鳞可以用到刮、
    可以用手拔（我第一次杀鱼就是用手拔的鱼鳞<-_->），
    但是整体流程确实几乎不变的。
    2，模板模式是将一整套流程提取出来做了封装，对于流程内的实现可以被替换
    3， 下载报表功能或者数据图表，内容格式是固定的，但是表头，正文，表尾都是不容的。
    
### 访问者模式（Visitor Pattern）
    访问者（Visitor）模式： - 稳定的数据结构和易变的操作耦合问题（主要将数据结构与数据操作分离）
    在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，
    即每个元素有多个访问者对象访问。
    1，您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。
    2，可以做报表、UI、拦截器与过滤器（不同角色能拥有不同权限）
    
    3, 某公司OA系统中包含一个员工信息管理子系统，该公司员工包括正式员工和临时工，每周人力资源部和财务部等部门需要对员工数据进行汇总，汇总数据包括员工工作时间、员工工资等。该公司基本制度如下：
    (1) 正式员工每周工作时间为40小时，不同级别、不同部门的员工每周基本工资不同；如果超过40小时，超出部分按照100元/小时作为加班费；如果少于40小时，所缺时间按照请假处理，请假所扣工资以80元/小时计算，直到基本工资扣除到零为止。除了记录实际工作时间外，人力资源部需记录加班时长或请假时长，作为员工平时表现的一项依据。
    (2) 临时工每周工作时间不固定，基本工资按小时计算，不同岗位的临时工小时工资不同。人力资源部只需记录实际工作时间。
    人力资源部和财务部工作人员可以根据各自的需要对员工数据进行汇总处理，人力资源部负责汇总每周员工工作时间，而财务部负责计算每周员工工资。
    
    4, 访问者模式的目的是封装一些施加于某种数据结构元素之上的操作，
    一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。
    为不同类型的元素提供多种访问操作方式，
    且可以在不修改原有系统的情况下增加新的操作方式，
    这就是访问者模式的模式动机。
    
    5, 在医院付费、取药为实例。
    在这个实例中划价员和药房工作者作为访问者，
    药品作为访问元素、处方单作为对象结构，
       Vistor: 抽象访问者。为该对象结构中的ConcreteElement的每一个类声明的一个操作。
          ConcreteVisitor: 具体访问者。实现Visitor申明的每一个操作，每一个操作实现算法的一部分。
         Element: 抽象元素。定义一个Accept操作，它以一个访问者为参数。
          ConcreteElement: 具体元素 。实现Accept操作。
         ObjectStructure: 对象结构。能够枚举它的元素，可以提供一个高层的接口来允许访问者访问它的元素。
    
    6, 艺术公司利用“铜”可以设计出铜像，利用“纸”可以画出图画；
    造币公司利用“铜”可以印出铜币，利用“纸”可以印出纸币。
    对“铜”和“纸”这两种元素，两个公司的处理方法不同，
    所以该实例用访问者模式来实现比较适合。
    7, 年底，CEO和CTO开始评定员工一年的工作绩效，员工分为工程师和经理，CTO关注工程师的代码量、经理的新产品数量；CEO关注的是工程师的KPI和经理的KPI以及新产品数量。
    由于CEO和CTO对于不同员工的关注点是不一样的，这就需要对不同员工类型进行不同的处理。访问者模式此时可以派上用场了。
    
    	 
J2EE 模式
MVC 模式（MVC Pattern）
业务代表模式（Business Delegate Pattern）
组合实体模式（Composite Entity Pattern）
数据访问对象模式（Data Access Object Pattern）
前端控制器模式（Front Controller Pattern）
拦截过滤器模式（Intercepting Filter Pattern）
服务定位器模式（Service Locator Pattern）
传输对象模式（Transfer Object Pattern）
