1. 通过配置心跳保持长连接。
2. 推送不保证成功，因为网络抖动或者其他原因，有可能发送到一半的时候断开，或者客户端发送ACK失败。
在设计程序的时候，设计一个端口，用于客户端收到信息后的应答。


协程高效的原因是创建开销了，由程序员调度。

一个请求中的所有协程都是存在在当前进程中，不会跨进程的。


Swoole的协程在底层实现上是单线程的，因此同一时间只有一个协程在工作，协程的执行是串行的。这与线程不同，
多个线程会被操作系统调度到多个CPU并行执行。
一个协程正在运行时，其他协程会停止工作。当前协程执行阻塞IO操作时会挂起，底层调度器会进入事件循环。
当有IO完成事件时，底层调度器恢复事件对应的协程的执行。


进程的切换会影响消耗CPU

时间片  一个程序可以执行最大的时间
进程拥有自己的内存空间和上下文环境
遇到io让出CPU执行权限（最大效率利用CPU）
使用场景  IO阻塞的场景，不适用CPU密集型的场景。



场景

1。 限流。使用令牌桶。请求来一个获取一个令牌。完毕后，放回桶或者写一个定时任务，过一段时间增加一定数量的令牌。
2。 游戏。游戏中一个动作就推送一个动作指令给服务器，服务器再分发给其他客户端。
3。 直播。视频流采集 - 推送到服务端 -  服务端再推流。





协程所有的操作都可以再用户态完成，创建和切换的消耗更低。
swoole允许同时一个协程读，一个协程写。
协程栈是一个线性表。

进程
父进程和子进程相互独立。
子进程会复制父进程的内存空间和上下文环境。
修改某个子进程的内存空间，不会修改父进程或者其他子进程中内存空间。

子进程会复制父进程的io句柄。


管道是一组特殊的描述符
读（接收），写（发送）



对于局部变量，swoole会在事件回调函数返回之后释放。

在多进程开发模式下，进程内的全局变量所用的内存那也是保存在子进程内存堆的，也并非共享内存，所以在swoole开发中我们还是尽量避免使用全局变量！

Worker进程退出后Manager进程会重新拉起一个新的Worker进程


总结：

常驻内存减少了不小开销，swoole不错
应尽量避免使用全局变量，不用最好，没啥用
max_request可以解决php的内存溢出问题，但是主要还是要养成释放内存的习惯，因为max_request也有限制场景



### Swoole的进程模型

Master ( 主进程 ) 分成  主进程 ( Accept 和 信号处理等 ) 和 Reactor[线程]（ 处理TCP连接, 处理网络IO，收发数据等 ）
Manage (管理进程)
Worker ( 工作进程 )
Task ( swoole异步任务task )

深入理解swoole task：swoole的业务逻辑是同步阻塞运行的，有时候我们要做一些比较消耗内存和cpu或者磁盘的操作的时候，我们需要使用到异步task任务；即我们在跑我们业务逻辑的时候只要你运行task你就会开启新的进程去处理消耗大的操作，当前的业务逻辑的进程继续运行，他们之间互不干涉，这个就很好地解决了php不支持多线程操作的障碍；


一个多进程模式下的Swoole Server中，有且只有一个Master进程；有且只有一个Manager进程；却可以有n个Worker进程。

第一层，Master进程，这个是swoole的主进程,这个进程是用于处理swoole的核心事件驱动的，那么在这个进程当中可以看到它拥有一个MainReactor[线程]以及若干个Reactor[线程]，swoole所有对于事件的监听都会在这些线程中实现，比如来自客户端的连接，信号处理等。





Master、Manage、Worker、Task四种进程之间是怎么协作的：
1、Client主动Connect的时候，Client实际上是与Master进程中的某个Reactor线程发生了连接。
2、当TCP的三次握手成功了以后，由这个Reactor线程将连接成功的消息告诉Manager进程，再由Manager进程转交给Worker进程。
3、在这个Worker进程中触发了OnConnect的方法。
4、当Client向Server发送了一个数据包的时候，首先收到数据包的是Reactor线程，同时Reactor线程会完成组包，再将组好的包交给Manager进程，由Manager进程转交给Worker。
5、此时Worker进程触发OnReceive事件。
6、如果在Worker进程中做了什么处理，然后再用Send方法将数据发回给客户端时，数据则会沿着这个路径逆流而上。
7、Task进程主要处理一些占用时间较长的业务，主要处理Worker进程中占时较长的一些任务。


