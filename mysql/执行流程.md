### 查询语句的执行流程

客户端 - 连接器(管理连接，权限验证) - 查询缓存（如果开启查询缓存）- 分析器(语法分析) 

- 优化器(生成执行计划，索引选择) - 执行器(操作引擎，返回结果)


### MySQL查询执行路径

1. 客户端发送一条查询给服务器；

2. 服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段；

3. 服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划；

4. MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询；

5. 将结果返回给客户端。
MySQL将结果返回客户端是一个增量、逐步返回的过程。例如，在关联表操作时，一旦服务器处理完最后一个关联表，开始生成第一条结果时，MySQL就可以开始向客户端逐步返回结果集了。

这样处理有两个好处：服务器无需存储太多的结果，也就不会因为要返回太多的结果而消耗太多的内存。另外，这样的处理也让MySQL客户端第一时间获得返回的结果。

结果集中的每一行都会以一个满足MySQL客户端/服务器通信协议的封包发送，再通过TCP协议进行传输，在TCP传输过程中，可能对MySQL的封包进行缓存然后批量传输。




### MySQL客户端/服务器通信协议
MySQL客户端和服务器之间的通信协议是“半双工”的，这意味着，在任何野时刻，要么是由服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时执行。
所以，我们无法也无须将也消息切成小块独立来发送。

一般服务器响应给用户的数据通常很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整地接受整个返回结果，而不能简单地只去前面这个结果，然后让服务器停止发送。这就是为什么要加Limit




### 执行顺序 - 数据都是一部分一部分出来的，所以limit 1 才会加速
    一共有十一个步骤，最先执行的是FROM操作，最后执行的是LIMIT操作。每个操作都会产生一个虚拟表，该虚拟表作为一个处理的输入，看下执行顺序：
    
    (1) FROM:对FROM子句中的左表<left_table>和右表<right_table>执行笛卡儿积，产生虚拟表VT1;
    (2) ON: 对虚拟表VT1进行ON筛选，只有那些符合<join_condition>的行才被插入虚拟表VT2;
    (3) JOIN: 如果指定了OUTER JOIN(如LEFT OUTER JOIN、RIGHT OUTER JOIN)，那么保留表中未匹配的行作为外部行添加到虚拟表VT2，产生虚拟表VT3。如果FROM子句包含两个以上的表，则对上一个连接生成的结果表VT3和下一个表重复执行步骤1~步骤3，直到处理完所有的表;
    (4) WHERE: 对虚拟表VT3应用WHERE过滤条件，只有符合<where_condition>的记录才会被插入虚拟表VT4;
    (5) GROUP By: 根据GROUP BY子句中的列，对VT4中的记录进行分组操作，产生VT5;
    (6) CUBE|ROllUP: 对VT5进行CUBE或ROLLUP操作，产生表VT6;
    (7) HAVING: 对虚拟表VT6应用HAVING过滤器，只有符合<having_condition>的记录才会被插入到VT7;
    (8) SELECT: 第二次执行SELECT操作，选择指定的列，插入到虚拟表VT8中;
    (9) DISTINCT: 去除重复，产生虚拟表VT9;
    (10) ORDER BY: 将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生虚拟表VT10;
    (11) LIMIT: 取出指定街行的记录，产生虚拟表VT11，并返回给查询用户
    
    on是在生成临时表的时候使用的条件，不管on的条件是否起到作用，都会返回左表 (table_name1) 的行。
    where则是在生成临时表之后使用的条件，此时已经不管是否使用了left join了，只要条件不为真的行，全部过滤掉。
    
    T-SQL在查询各个阶级分别干了什么： 
    1. FROM阶段
    FROM阶段标识出查询的来源表，并处理表运算符。在涉及到联接运算的查询中（各种JOIN），主要有以下几个步骤：
    
    求笛卡尔积。不论是什么类型的联接运算，首先都是执行交叉连接（CROSS JOIN），求笛卡儿积（Cartesian product），生成虚拟表VT1-J1。
    ON筛选器。  这个阶段对上个步骤生成的VT1-J1进行筛选，根据ON子句中出现的谓词进行筛选，让谓词取值为true的行通过了考验，插入到VT1-J2。
    添加外部行。如果指定了OUTER JOIN，如LEFT OUTERJOIN、RIGHT OUTER JOIN），还需要将VT1-J2中没有找到匹配的行，作为外部行添加到VT1-J2中，生成VT1-J3。如果FROM子句包含两个以上表，则对上一个连接生成的结果表VT1-J3和下一个表重复依次执行3个步骤，直到处理完所有的表为止。
    经过以上步骤，FROM阶段就完成了。
    
    2. WHERE阶段
    WHERE阶段是根据<where_predicate>中条件对VT1中的行进行筛选，让条件成立的行才会插入到VT2中。此时数据还没有分组，所以不能在WHERE中出现对统计的过滤。
    
    3. GROUP BY阶段
    GROUP阶段按照指定的列名列表，将VT2中的行进行分组，生成VT3。最后每个分组只有一行。在GROUP BY阶段，数据库认为两个NULL值是相等的，因此会将NULL值分到同一个分组中。
    
    4. HAVING阶段
    该阶段根据HAVING子句中出现的谓词对VT3的分组进行筛选，并将符合条件的组插入到VT4中。COUNT(expr) 会返回expr不为NULL的行数，count(1)、count(*)会返回包括NULL值在内的所有数量。
    
    5. SELECT阶段
    这个阶段是投影的过程，处理SELECT子句提到的元素，产生VT5。这个步骤一般按下列顺序进行：
    
    计算SELECT列表中的表达式，生成VT5-1。
    若有DISTINCT，则删除VT5-1中的重复行，生成VT5-2。
    6. ORDER BY阶段
    根据ORDER BY子句中指定的列明列表，对VT5-2中的行，进行排序，生成VT6。如果不指定排序，数据并非总是按照主键顺序进行排序的。NULL被视为最小值。
    
    7. LIMIT阶段
    取出指定行的记录，产生虚拟表VT7，并返回给查询用户。LIMIT n, m的效率是十分低的，一般可以通过在WHERE条件中指定范围来优化 WHERE id > ? limit 10。