### 表压缩
1. Myisam引擎支持对表的压缩,压缩后的空间上比压缩前会减少60%-70%,但是压缩后的表是只读。
    可以使用--unpack参数解压缩表，但是解压缩后的表依然是只读的。
2. InnoDB引擎的压缩特色效果不错，压缩完后快和MyISAM引擎差不多了。
   不过压缩后事务并发性能下降非常严重，从这个角度来看，它适合用于对压缩比较高、但对并发事务要求不高的场景
    
### 表设计字段是否有空
1. 尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。
2. 在MySQL中，含有空值的列很难进行查询优化。
3. 因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。
4. null会影响索引的统计，一般会默认null为同一个值，这样这个索引的筛选价值就降低了，影响优化器的判断。
5. 当然也可以调整参数，使得null被认为是不同的值。
6. 可空列被索引后，每条记录都需要一个额外的字节，还能导致MYisam 中固定大小的索引变成可变大小的索引。
7. 可空列需要更多的存储空间;



1、空值是不占用空间的

2、mysql中的NULL其实是占用空间的，



# 主键
如果要插入的表没有主键或非空的唯一键的话， innodb就会从全局
为这行分配一个row_id。 由于是全局锁，非常的影响插入性能。
1. 显式的定义一个 INT 类型自增字段的主键，这个字段可以仅用于做主键，不做其他用途
2. 如果不显式定义主键的话，可能会导致InnoDB每次都需要对新数据行进行排序，严重损害性能
3. 尽量保证不对主键字段进行更新修改，防止主键字段发生变化，引发数据存储碎片，降低IO性能
4. 如果需要对主键字段进行更新，请将该字段转变成一个唯一索引约束字段，另外创建一个没有其他业务意义的自增字段做主键
5. 主键字段类型尽可能小，能用SMALLINT就不用INT，能用INT就不用BIGINT
6. 主键字段放在数据表的第一顺序

# 建立自增主键的原因是：
Innodb中的每张表都会有一个聚集索引，而聚集索引又是以物理磁盘顺序来存储的，自增主键会把数据自动向后插入，避免了插入过程中的聚集索引排序问题。聚集索引的排序，必然会带来大范围的数据的物理移动，这里面带来的磁盘IO性能损耗是非常大的。
而如果聚集索引上的值可以改动的话，那么也会触发物理磁盘上的移动，于是就可能出现page分裂，表碎片横生。



# 临时表的产生
1. sql执行会生成一个巨大的临时表，当内存放不下时，要全部copy 到磁盘，导致IO飙升，时间开销增大。
2. MySQL临时表分为“内存临时表”和“磁盘临时表”，
从5.7.5开始，新增一个系统选项 internal_tmp_disk_storage_engine 可定义磁盘临时表的引擎类型为 InnoDB，而在这以前，只能使用 MyISAM。而在5.6.3以后新增的系统选项 default_tmp_storage_engine 是控制 CREATE TEMPORARY TABLE 创建的临时表的引擎类型，在以前默认是MEMORY，不要把这二者混淆了。

3. 直接使用磁盘临时表的场景
   
   1)表包含TEXT或者BLOB列;
   
   2)GROUP BY 或者 DISTINCT 子句中包含长度大于512字节的列;
   
   3)使用UNION或者UNION ALL时，SELECT子句中包含大于512字节的列;
   
   
### MySQL会创建临时表的几种情况
    1、UNION查询；
    2、用到TEMPTABLE算法或者是UNION查询中的视图；
    3、ORDER BY和GROUP BY的子句不一样时；
    4、表连接中，ORDER BY的列不是驱动表中的；（指定了联接条件时，满足查询条件的记录行数少的表为[驱动表]，未指定联接条件时，行数少的表为[驱动表]，多表联合查询时）
    5、DISTINCT查询并且加上ORDER BY时；
    6、SQL中用到SQL_SMALL_RESULT选项时；
    7、FROM中的子查询；
    8、子查询或者semi-join时创建的表；
    
    
    
### 一张表存储多少数据性能是最高的
    对于表记录数需要考虑的是记录数的临界点，即：表达到这个记录数后，
    表大小（数据和索引）超过了Innodb buffer pool的大小；而设计时推荐尽量设计和试用行长度小而精的表。
    
1. 行长度对性能影响更大，行越长性能越低
2. 表记录数本身对性能影响不大，关键是表的大小是否小于Innodb buffer pool。