1、错误日志（errorlog）：记录mysql服务的启动、运行、停止mysql服务时出现的问题

2、一般查询日志（general log）：记录建立的客户端连接和执行的语句

3、二进制日志（binlog）：记录所有更改数据的语句，可以用于数据复制

4、慢查询日志（slow query log）：记录所有执行时间超过long_query_time的所有查询或不使用索引的查询


5. 回滚日志（undo log）

    作用：
    　　保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读
    
    内容：
    　　逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。
    
    什么时候产生：
    　　事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性
    
    什么时候释放：
    　　当事务提交之后，undo log并不能立马被删除，
    　　而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。

6. 重做日志（redo log）
    
    作用：
    　　确保事务的持久性。
    　　防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。
    内容：
    　　物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。
    什么时候产生：
    　　事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。
    什么时候释放：
    　　当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。



假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。

在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。
同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。

回滚日志总不能一直保留，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。

要使用长事务， 长事务还占用锁资源，也可能拖垮整个库



MySQL binlog日志格式 binlog_format
MySQL 5.5 中对于二进制日志 (binlog) 有 3 种不同的格式可选：Mixed,Statement,Row，默认格式是 Statement。总结一下这三种格式日志的优缺点。
MySQL Replication 复制可以是基于一条语句 (Statement Level) ，也可以是基于一条记录 (Row Level)，可以在 MySQL 的配置参数中设定这个复制级别，不同复制级别的设置会影响到 Master 端的 bin-log 日志格式。

1. Row (不记录每一条SQL语句的上下文信息，仅需记录哪条数据被修改了，修改成了什么样子了。)
日志中会记录成每一行数据被修改的形式，然后在 slave 端再对相同的数据进行修改。

2. Statement (每一条会修改数据的sql语句会记录到binlog中)
每一条会修改数据的 SQL 都会记录到 master 的 bin-log 中。slave 在复制的时候 SQL 进程会解析成和原来 master 端执行过的相同的 SQL 再次执行。
可能会使 slave 和 master 上得到不一致的 id 等等。由于 row 是基于每一行来记录的变化，所以不会出现类似的问题。

3. Mixed

从 5.1.8 版本开始，MySQL 提供了除 Statement 和 Row 之外的第三种复制模式：Mixed，实际上就是前两种模式的结合。

在 Mixed 模式下，MySQL 会根据执行的每一条具体的 SQL 语句来区分对待记录的日志形式，也就是在 statement 和 row 之间选择一种。





