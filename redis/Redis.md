
给redis上锁的方式
$token = rand(1, 99999);
// 这里在java的解决方案是开一个线程，每个几秒去检查一次，如果还存在就加时。
if (Redis::set("my:lock", $token, "nx", "ex", 10)) {
    ... do something
    
    if ($token == Redis::get("my:lock")) {
        Redis::del("my:lock");
    }
}





二、缓存穿透
描述：
缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，
如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。

解决方案：
1. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，
缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击


三、缓存击穿

描述：
缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，
同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力

解决方案：
1. 设置热点数据永远不过期。
2. 加互斥锁(每次只有少数请求能到数据库)。


四、缓存雪崩
描述：
缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。
和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。

解决方案：
1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
2. 如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。
3. 设置热点数据永远不过期。



主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，
还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。

哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。
其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。




如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于39字节，
那么字符串对象将使用embstr编码的方式来保存这个字符串值。


embstr好处：

embstr编码是专门用于保存短字符串的一种优化编码方式，跟正常的字符编码相比，
字符编码会调用两次内存分配函数来分别创建redisObject和sdshdr结构，
而embstr编码则通过调用一次内存分配函数来分配一块连续的空间，
空间中一次包含redisObject和sdshdr两个结构。


redIsObject占用16字节
cpu -> cache line 64 byte
结构体占了4个字节


Redis-对象
在以前的文章中，我们介绍了 Redis 用到的主要数据结构，比如简单动态字符串、双端链表、字典、压缩列表、整数集合。
然而 Redis 并没有直接使用这些数据结构来实现键值对的数据库，而是在这些数据结构之上又包装了一层
 RedisObject（对象），RedisObject 
 
 数据类型对应的数据结构
 string (int, raw, embstr)
 list (quicklist)
 hash (hashtable, ziplist)
 set (hashtable, intset)
 zset (ziplist, sliplist)
 
 Redis短结构
 　　Redis为列表、集合、散列和有序集合提供了一组配置选项（配置文件中），
 这些选项可以让Redis以更加节约空间的方式存储长度较短的结构（即短结构）。
 
 　　在列表、散列和有序集合的长度较短或者体积较小的时候，Redis可以选择使用一种名为压缩列表（ziplist）
 的紧凑存储方式来存储这些结构。压缩列表会以序列化的方式存储数据，这些序列化数据每次被读取的时候都要就行解码，
 每次被写入的时候都要进行局部的重新编码，并且可能需要对内存里的数据进行移动。
 因此读写一个长度较大的压缩列表可能会给性能带来负面的影响。
 
 
 list-max-ziplist-entries 512
 list-max-ziplist-value 64　　　　　　　　　　当列表的元素长度都小于64字节并且列表元素数量小于512时，使用压缩列表，反之使用linkedlist。
 
 hash-max-ziplist-entries 512
 hash-max-ziplist-value 64　　　　　　　　　　当散列的元素的键和值都小于64字节并且键值对的数量小于512时，使用压缩列表，反之使用hashtable
 
 zset-max-ziplist-entries 128
 zset-max-ziplist-value 64　
 当有序集合的元素都小于64字节并且元素数量小于128个的时候，使用压缩列表，反之使用skiplist
 
 
 
 Redis 采用单线程模式处理请求。这样做的原因有 2 个：一个是因为采用了非阻塞的异步事件处理机制；
 另一个是缓存数据都是内存操作 IO 时间不会太长，单线程可以避免线程上下文切换产生的代价； 
 Redis 支持持久化，所以 Redis 不仅仅可以用作缓存，也可以用作 NoSQL 数据库； 
 相比 MC，Redis 还有一个非常大的优势，就是除了 K-V 之外，还支持多种数据格式，
 例如 list、set、sorted set、hash 等；
 
 布隆过滤器原理
 原理就是一个对一个key进行k个hash算法获取k个值，在比特数组中将这k个值散列后设定为1，
 然后查的时候如果特定的这几个位置都为1，那么布隆过滤器判断该key存在。
 
 布隆过滤器可能会误判，如果它说不存在那肯定不存在，如果它说存在，那数据有可能实际不存在；
 
 Redis的bitmap只支持2^32大小，对应到内存也就是512MB，误判率万分之一，可以放下2亿左右的数据，性能高，空间占用率及小，
 省去了大量无效的数据库连接。
 
 因此我们可以通过布隆过滤器，将Redis缓存穿透控制在一个可容范围内。
 布隆过滤器另一个用途——推荐去重
 
 
 高级用法
 Bitmap : 位图是支持按 bit 位来存储信息，可以用来实现 布隆过滤器（BloomFilter）； 
 
 HyperLogLog: 供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV； 
 HyperLogLog 提供不精确的去重计数方案，标准误差大概在 0.81%。
 当一个请求过来时，我们使用 sadd 将用户 ID 塞进去就可以了
 
 Geospatial: 可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。
 pub/sub： 功能是订阅发布功能，可以用作简单的消息队列。 
 Pipeline： 可以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。 
 Lua： Redis 支持提交 Lua 脚本来执行一系列的功能。
 
 事务： 最后一个功能是事务，但 Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，
 但是执行命令失败时并不会回滚，而是会继续执行下去。
 
 
 lazy free 特性是 Redis 4.0 新增的一个非常实用的功能，它可以理解为惰性删除或延迟删除。意思是在删除的时候提供异步延时释放键值的功能，把键值释放操作放在 BIO (Background I/O) 单独的子线程处理中，以减少删除操作对 Redis 主线程的阻塞，可以有效的避免删除 big key 时带来的性能和可用性问题.



主从redis，分布式锁更加复杂，主从同步失败，锁有可能失效。如果遇到锁失效，处理方案是？
RedLock 可以一定程度上缓解。

CAP 一致性，可用性，分区容错性。


无底洞现象 不是加机器性能就提高了，因为同步会消耗性能。

ServerCron redis的过期清理定时器 默认一秒10次。



8种数据淘汰策略
1. noeviction：当内存使用超过配置的时候会返回错误，不会驱逐任何键
2. allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键
3. volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键
4. allkeys-random：加入键的时候如果过限，从所有key随机删除
5. volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐
6. volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键
7. volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键
8. allkeys-lfu：从所有键中驱逐使用频率最少的键

内存不够的时候的缓存淘汰算法 LRU / LFU

在每个key中存在一个额外的长度24bit的小字段，记录最后一次被访问的时间戳。
max_memory_samples = 5

redis的key使用双向链表连接起来。
k1 <-> k2 <-> k3 <-> k4



LRU  最近最少使用

redis 用随机采样法来淘汰元素。

Redis中的LRU与常规的LRU实现并不相同，常规LRU会准确的淘汰掉队头的元素，但是Redis的LRU并不维护队列，
只是根据配置的策略要么从所有的key中随机选择N个（N可以配置）要么从所有的设置了过期时间的key中选出N个键，
然后再从这N个键中选出最久没有使用的一个key进行淘汰。

为什么要使用近似LRU？
1、性能问题，由于近似LRU算法只是最多随机采样N个key并对其进行排序，如果精准需要对所有key进行排序，这样近似LRU性能更高

2、内存占用问题，redis对内存要求很高，会尽量降低内存使用率，如果是抽样排序可以有效降低内存的占用

3、实际效果基本相等，如果请求符合长尾法则，那么真实LRU与Redis LRU之间表现基本无差异

4、在近似情况下提供可自配置的取样率来提升精准度，例如通过 CONFIG SET maxmemory-samples <count> 
指令可以设置取样数，取样数越高越精准，如果你的CPU和内存有足够，可以提高取样数看命中率来探测最佳的采样比例。



LFU (最不常用使用) 24bit lru字段
1。 高16位，用来记录时间（分钟）
2。 低8位，用来记录访问频率。

新生KEY策略
另外一个问题是，当创建新对象的时候，对象的counter如果为0，很容易就会被淘汰掉，
还需要为新生key设置一个初始counter。counter会被初始化为LFU_INIT_VAL，默认5。
