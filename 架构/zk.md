1. 为什么需要分布式锁
2. 基于mysql的分布式锁有什么缺陷
3. zk节点特性分析
4. 基于zk实现分布式锁

为什么需要锁
    1. 多任务环境才需要
    2. 任务都需要对同一共享资源进行写操作
    3. 对资源的访问是互斥的


业务场景
    在分布式架构下，生成全局唯一订单
    

分布式锁是指在分布式环境下，多个操作要以原子的方式执行。




CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾
一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）
可用性（A）：保证每个请求不管成功或者失败都有响应。
分区容忍性（P）：系统中任意信息的丢失或失败不会影响系统的继续运作。


CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于网络硬件肯定会出现延迟丢包等问题，所以分区容错性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地。
数据库事务一致性需求　　很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低，有些场合对写一致性要求并不高。允许实现最终一致性。
数据库的写实时性和读实时性需求　　对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比方说发一条消息之 后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。
对复杂的SQL查询，特别是多表关联查询的需求　　任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特别是SNS类型的网站，从需求以及产品设计角 度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。


分布式锁实现

mysql         
优点： 直接使用数据库，使用简单     
缺点： 分布式系统大多数瓶颈都在数据库，使用数据库锁会增加数据库负担。

redis
优点：
    性能高，实现起来比价方便，在允许偶发的锁失效情况，不影响系统正常使用，建议采用redis实现。
缺点：
    通过锁超时机制不是十分可靠，当线程获取锁后，处理时间超长导致锁超时，就失效了锁的作用。

zookeeper
优点：
    不依靠超时时间释放锁；可靠性高，系统要求高可靠性时，建议采用。
缺点：
    性能比不上缓存锁，因为要频繁的创建节点删除节点。




zookeeper = 文件系统 + 监听通知机制

知识点
1. 持久化节点，客户端与zk断开连接后，节点还在。
2. 持久化有序节点，客户端与zk断开连接后，节点还在，只是zk给节点名称进行排序编号。
2. 临时节点，客户端和zk断开连接后，节点被删除。
3. 临时有序节点，客户端和zk断开连接后，节点被删除。

基于临时节点（悲观锁）
1. 创建临时节点，断开连接就会删除节点
2. 会监听节点，删除锁后会通知其他的请求。


基于临时有序节点（乐观锁）
1. 在locks下创建临时有序节点
2. 获取呀locks喜爱所有子节点
3. 将子节点按序号由小到大排序
4. 当前节点是否是最小
5. 最小的获取锁，其他的堵塞，监听比自己小1的节点的删除事件，比自己小1的节点删除后，下一轮开始。
6. 获取锁
7. 删除锁节点，释放锁

文件系统可以存储1M

