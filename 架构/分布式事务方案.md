### 柔性事务解决方案
1. TCC - 两阶段型，补偿型
    描述：
        try：尝试执行业务
        confirm：确认执行业务
        cancel 取消执行业务

        do：真正执行业务
        compensate：业务补偿 - 补偿操作满足幂等性
    实现：
        一个完整的业务活动由一个主业务服务与若干从业务服务组成
        主业务服务负责发起并完成这个那个业务活动
        从业务服务提供TCC型业务操作
            业务活动管理控制业务活动的一致性，它登记业务活动中的操作，并在业务活动提交时确认所有的TCC型操作的confirm操作，
        在业务活动取消时调用所有TCC型操作的cancel操作
    模型：
        主业务服务A ( 启动业务活动，登记业务操作，提交/回滚业务活动 ) 
            -> 业务活动管理器（ 活动日志 ) 
            -> Try ( 从业务服务A + 从业务服务B 做预处理) 
            -> Confirm or Cancel ( 从业务服务A + 从业务服务B )
    注意：每一步都需要符合幂等性

2. 最大努力通知（定期校对）- 依赖MQ
    描述：
        业务活动的主动方，在完成业务处理之后，向业务活动的被动方发送消息，允许消息丢失。
        业务活动的被动方根据定时策略，向业务活动主动方查询，恢复丢失的业务消息。
    使用场景：支付通知
    模型：
        业务处理 -> MQ（消息存储） -> 消费端(发送通知，通知记录)
3. 可靠消息最终一致（异步确何型）
    3.1 本地消息服务
        实现：
            正向流程 ： 业务处理 -> MQ -> 消费（被动方应用系统）
            异常流程 ： 业务处理 -> 消息恢复系统(定时任务) -> MQ -> 消费（被动方应用系统）
        优点：
            消息时效性比较高
            数据可靠性不依赖MQ，弱化对MQ的依赖性
            方案轻量，容易实现
        缺点：
            与具体的业务场景绑定，耦合性强，不可公用
            消息数据与业务数据同库，占用业务系统资源
            受关系型数据库并发性能的局限
    3.2 独立消息服务
        实现：
            消息发送一致性的正向流程 :
                主动方应用系统 -> 消息服务子系统（存储发送的消息，确认发送消息）-- 需要保存数据到消息服务库
            消息发送一致性的异常流程 ：
                主动方应用系统 -> 消息状态确认子系统(定时任务) -> 消息服务子系统（查询状态确认超时的消息）
            消息投递（消息）的正向流程 ：
                消息服务子系统 -> MQ -> 消费（被动方应用系统）
            消息投递（消息）的异常流程 ：
                消息服务子系统（确认消息已经被成功消费，查询消费确认超时的消息） -> 消息恢复系统(定时任务) -> MQ -> 消费（被动方应用系统）
            消息管理子系统：
                管理消息重试，监控等处理。
        原理：
            本地消息服务每种业务都需要实现一套，把这个模式抽象出来就成为了独立消息服务。
        优点：
            消息服务独立部署，独立维护，独立伸缩
            消息存储可以按需选择不同的数据库来集成实现
            消息服务可以被相同的使用场景共用，降低重复建设消息服务的成本
            从分布式服务设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖MQ
            降低业务系统与消息系统之间的耦合，有利于系统的扩展维护
        缺点：
            一次消息发送需要两次请求
            主动方应用系统需要实现业务操作状态校验查询接口
    3.3 使用场景：下单

4. 纯补偿型

### 刚性事务
1. 全局事务（标准的分布式事务）- 例如mysql的XA


BASE理论
1. BA： basic availability 基本业务可用性（支持分区失败）
2. S：soft state 柔性状态（状态 允许有短时间不同步，异步）
3. E：eventual consistency 最终一致性（最终数据是一致的，但不是实时一致）
原子性A与持久性D必须根本保障
为了可用性，性能与降级服务的需要，只有降低一致性（C）与隔离性（I）的要求。

CAP定理
1. C 一致性 - 所有用户看一致的数据
2. A 可用性 - 总能找到一个可用的数据复本
3. P 分区容错性 - 容忍网络中断
结论：分布式系统中，最重要的是满足业务需求，而不是最求抽象，绝对的系统特性。