### 方案
    0. CAS:Compare and Swap,即比较再交换。 在程序上 do {} while(), 操作。
    1、单线程来主导行为，多线程池化操作避开状态变量。
    
    比如在一个WEB应用中，每一个Action都可以给相应的用户线程分配一个实例，线程之间互不干扰；但是到了业务逻辑Service内，避开Service状态变量的使用，减少了开发人员对并发编程的关注。
    
    2、函数式编码。
    
    函数式编码是最天然的和最高效的免锁方式，如果你对函数式编码还不了解，请参看这篇文章。
    
    3、资源局部复制、异步处理。
    
    总所周知对资源的争夺是造成锁的一个重要原因，在很多情况下，资源只能有一份，但是对使用资源的每个线程来说，都可以看到属于它自己的一份（这一份并非是真正的资源，很可能只是一个缓冲区，每个线程使用它自己的一个缓冲区，到一定程度时将缓冲区的数据处理到唯一资源中，这就减少了需要加锁对线程的影响），无需考虑并发地去使用。
    
    4、不变对象。
    
    不妨参考ConcurrentHashMap的实现，其中的节点是不变的。对象不变性是保证线程安全的重要方式之一。
    
    
    
    
参考文章
https://blog.csdn.net/kjfcpua/article/details/11937817
https://blog.csdn.net/raychase/article/details/6179836