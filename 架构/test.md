设计具备良好可扩展性的系统，有两个基本条件：正确预测变化、完美封装变化。


第一种应对变化的常见方案是将“变化”封装在一个“变化层”，将不变的部分封装在一个独立的“稳定层”。

1. 系统需要拆分出变化层和稳定层
2. 需要设计变化层和稳定层之间的接口

第二种常见的应对变化的方案是提炼出一个“抽象层”和一个“实现层”。抽象层是稳定的，实现层可以根据具体业务需要定制开发，当加入新的功能时，只需要增加新的实现，无须修改抽象层。






合适原则、简单原则、演化原则，架构设计时遵循这几个原则，有助于你做出最好的选择。


合适原则宣言：“合适优于业界领先”。
1. 将军难打无兵之仗
没那么多人，却想干那么多活，是失败的第一个主要原因。
2. 罗马不是一天建成的
没有那么多积累，却想一步登天，是失败的第二个主要原因。
3. 冰山下面才是关键
没有那么卓越的业务场景，却幻想灵光一闪成为天才，是失败的第三个主要原因。

简单原则宣言：“简单优于复杂”。
软件领域的复杂性体现在两个方面
1. 结构的复杂性
2. 逻辑的复杂性

演化原则宣言：“演化优于一步到位”。

首先，设计出来的架构要满足当时的业务需要。

其次，架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善。

第三，当业务发生变化时，架构要扩展、重构，甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等（类似生物体内的基因）却可以在新架构中延续。




架构设计第 1 步：识别复杂度
架构设计第 2 步：设计 3 ~ 5 个备选方案.
架构设计第 3 步：评估和选择备选方案
360 度环评：列出我们需要关注的质量属性点，然后分别从这些质量属性的维度去评估每个方案，再综合挑选适合当时情况的最优方案。
架构设计第 4 步：详细方案设计





FMEA方法，排除架构可用性隐患的利器
FMEA 方法
在架构设计领域，FMEA 的具体分析方法是：
给出初始的架构设计图。
假设架构中某个部件发生故障。
分析此故障对系统功能造成的影响。
根据分析结果，判断架构是否需要进行优化。

1.功能点
2.故障模式
3.故障影响
4.严重程度
5.故障原因
6.故障概率
7.风险程度
8.已有措施
9.规避措施
10.解决措施
11.后续规划



CAP
对于某些严苛的业务场景，例如和金钱相关的用户余额，或者和抢购相关的商品库存，技术上是无法做到分布式场景下完美的一致性的。而业务上必须要求一致性，因此单个用户的余额、单个商品的库存，理论上要求选择 CP 而实际上 CP 都做不到，只能选择 CA。也就是说，只能单点写入，其他节点做备份，无法做到分布式情况下多点写入。


CAP 理论告诉我们分布式系统只能选择 CP 或者 AP，但其实这里的前提是系统发生了“分区”现象。如果系统没有发生分区现象，也就是说 P 不存在的时候（节点间的网络连接一切正常），我们没有必要放弃 C 或者 A，应该 C 和 A 都可以保证，这就要求架构设计的时候既要考虑分区发生时选择 CP 还是 AP，也要考虑分区没有发生时如何保证 CA。



架构重构内功心法第一式：有的放矢
从一大堆纷繁复杂的问题中识别出真正要通过架构重构来解决的问题，集中力量快速解决，而不是想着通过架构重构来解决所有的问题。
架构重构内功心法第二式：合纵连横
在沟通协调时，将技术语言转换为通俗语言，以事实说话，以数据说话，是沟通的关键！

有效的策略是“换位思考、合作双赢、关注长期”。简单来说就是站在对方的角度思考，重构对他有什么好处，能够帮他解决什么问题，带来什么收益。

架构重构内功心法第三式：运筹帷幄
总结一下重构的做法，其实就是“分段实施”，将要解决的问题根据优先级、重要性、实施难度等划分为不同的阶段，每个阶段聚焦于一个整体的目标，集中精力和资源解决一类问题。




对于框架的选择，有一个总的原则：优选成熟的框架，避免盲目追逐新技术！



每个团队的人数不能多到两张披萨都不够吃的地步
一个微服务三个人负责开发。


拆分方法s
1. 基于业务逻辑拆分 例如 ： “商品”“交易”“用户”3 个服务
2. 基于可扩展拆分 例如： 稳定服务 or 变动服务
3. 基于可靠性拆分
将系统中的业务模块按照优先级排序，将可靠性要求高的核心服务和可靠性要求低的非核心服务拆分开来，然后重点保证核心服务的高可用。



可扩展的基本思想
基本思想都可以总结为一个字：拆！
面向流程拆分：将整个业务流程拆分为几个阶段，每个阶段作为一部分。

面向服务拆分：将系统提供的服务拆分，每个服务作为一部分。

面向功能拆分：将系统提供的功能拆分，每个功能作为一部分。
不同的拆分方式，本质上决定了系统的扩展方式。


代码之丑 ： 
1. 长参数的处理方法
一个模型（实体类 / 参数类）的封装应该是以行为为基础的
2. request不能直接传递到service中，需要使用参数类传输到service，用于隔开request和service。
3. service中不应该存在业务之外的代码。
4. 变量一次性完成初始化，不要先初始化变量，再赋值。如果变量的处理比较复杂。封装成一个方法。
5. 函数越短越好，不能超过100行。
6. 类写得越小越好。
7. 代码评审暴露问题越多越好，频率越高越好。
8. 把代码写到不需要注释，而把注释当作最后得选择就可以了。
9. 对于业务系统而言，实体是其中最核心得部分，对它得修改必须需要谨慎得思考。
10. 代码中的标记参数，可以通过拆分函数的方式将它们拆开。
11. 注意过长的消息链。不要暴露细节，使用迪米特法则处理。
12. 一些基本类型，需要在业务上做大量判断得，可以使用对象取代基本类型方法，把判断逻辑和计算逻辑封装在对象中。
13. 组合优于继承。
14. 使用函数或者构造函数代替setter。把不可控的变化封装起来。
15. DDD中，实体对象要限制数据变化，值对象要设计成不变类。
16. 编写不变类去解决可变数据。不变类，所有字段只能在构造函数中初始化，所有方法都是纯函数，需要修改，返回一个新的对象，而不是修改已经有的字段。
17. 多个switch条件，可以使用多态取代。


领域驱动设计 ： 
DDD 核心思想是通过领域驱动设计方法定义领域模型，从而确定业务和应用边界，保证业务模型与代码模型的一致性。

DDD 不是架构，而是一种架构设计方法论，它通过边界划分将复杂业务领域简单化，帮我们设计出清晰的领域和应用边界，可以很容易地实现架构演进。


建模步骤：
DDD 战略设计会建立领域模型，领域模型可以用于指导微服务的设计和拆分。事件风暴是建立领域模型的主要方法，它是一个从发散到收敛的过程。它通常采用用例分析、场景分析和用户旅程分析，尽可能全面不遗漏地分解业务领域，并梳理领域对象之间的关系，这是一个发散的过程。事件风暴过程会产生很多的实体、命令、事件等领域对象，我们将这些领域对象从不同的维度进行聚类，形成如聚合、限界上下文等边界，建立领域模型，这就是一个收敛的过程。

第一步：在事件风暴中梳理业务过程中的用户操作、事件以及外部依赖关系等，根据这些要素梳理出领域实体等领域对象。

第二步：根据领域实体之间的业务关联性，将业务紧密相关的实体进行组合形成聚合，同时确定聚合中的聚合根、值对象和实体。在这个图里，聚合之间的边界是第一层边界，它们在同一个微服务实例中运行，这个边界是逻辑边界，所以用虚线表示。

第三步：根据业务及语义边界等因素，将一个或者多个聚合划定在一个限界上下文内，形成领域模型。在这个图里，限界上下文之间的边界是第二层边界，这一层边界可能就是未来微服务的边界，不同限界上下文内的领域逻辑被隔离在不同的微服务实例中运行，物理上相互隔离，所以是物理边界，边界之间用实线来表示。

有了这两层边界，微服务的设计就不是什么难事了。




DDD 与微服务的关系
有了上面的讲解，现在我们不妨再次总结下 DDD 与微服务的关系。

DDD 是一种架构设计方法，微服务是一种架构风格，两者从本质上都是为了追求高响应力，而从业务视角去分离应用系统建设复杂度的手段。两者都强调从业务出发，其核心要义是强调根据业务发展，合理划分领域边界，持续调整现有架构，优化现有代码，以保持架构和代码的生命力，也就是我们常说的演进式架构。

DDD 主要关注：从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。

微服务主要关注：运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署。



领域就是用来确定范围的，范围即边界，这也是 DDD 在设计中不断强调边界的原因。



在领域不断划分的过程中，领域会细分为不同的子域，子域可以根据自身重要性和功能属性划分为三类子域，它们分别是：核心域、通用域和支撑域。

决定产品和公司核心竞争力的子域是核心域，它是业务成功的主要因素和公司的核心竞争力。没有太多个性化的诉求，同时被多个子域使用的通用功能子域是通用域。还有一种功能子域是必需的，但既不包含决定产品和公司核心竞争力的功能，也不包含通用功能的子域，它就是支撑域。



什么是通用语言？
在事件风暴过程中，通过团队交流达成共识的，能够简单、清晰、准确描述业务涵义和规则的语言就是通用语言。



通用语言包含术语和用例场景，并且能够直接反映在代码中。通用语言中的名词可以给领域对象命名，如商品、订单等，对应实体对象；而动词则表示一个动作或事件，如商品已下单、订单已付款等，对应领域事件或者命令。




1. 在事件风暴的过程中，领域专家会和设计、开发人员一起建立领域模型，在领域建模的过程中会形成通用的业务术语和用户故事。事件风暴也是一个项目团队统一语言的过程。
2. 通过用户故事分析会形成一个个的领域对象，这些领域对象对应领域模型的业务对象，每一个业务对象和领域对象都有通用的名词术语，并且一一映射。
3. 微服务代码模型来源于领域模型，每个代码模型的代码对象跟领域对象一一对应。
4. 这里我再给你分享一条经验，我自己经常用，特别有效。设计过程中我们可以用一些表格，来记录事件风暴和微服务设计过程中产生的领域对象及其属性。
5. DDD 分析和设计过程中的每一个环节都需要保证限界上下文内术语的统一，在代码模型设计的时侯就要建立领域对象和代码对象的一一映射，从而保证业务模型和代码模型的一致，实现业务语言与代码语言的统一。




限界上下文拆解为两个词：限界和上下文。限界就是领域的边界，而上下文则是语义环境。
正如电商领域的商品一样，商品在不同的阶段有不同的术语，在销售阶段是商品，而在运输阶段则变成了货物。同样的一个东西，由于业务领域的不同，赋予了这些术语不同的涵义和职责边界，这个边界就可能会成为未来微服务设计的边界。看到这，我想你应该非常清楚了，领域边界就是通过限界上下文来定义的。



理论上限界上下文就是微服务的边界。我们将限界上下文内的领域模型映射到微服务，就完成了从问题域到软件的解决方案。

可以说，限界上下文是微服务设计和拆分的主要依据。在领域模型中，如果不考虑技术异构、团队沟通等其它外部因素，一个限界上下文理论上就可以设计为一个微服务。


### 实体
有这样一类对象，它们拥有唯一标识符，且标识符在历经各种状态变更后仍能保
持一致。对这些对象而言，重要的不是其属性，而是其延续性和标识，对象的延续性和标识
会跨越甚至超出软件的生命周期。

实体具有唯一性和不变性。
###  值对象
值对象是不变类。
通过对象属性值来识别的对
象，它将多个相关属性组合为一个概念整体。
值对象描述了领域中的一件东西，这个东西是不可变的，它将不同的相关属性组合
成了一个概念整体。当度量和描述改变时，可以用另外一个值对象予以替换。它可以和其它
值对象进行相等性比较，且不会对协作对象造成副作用。

### 实体和值对象的区别例子
人员实体原本包括：姓名、年龄、性别以及人员所在的省、市、县和街道等属性。这样显示
地址相关的属性就很零碎了对不对？现在，我们可以将“省、市、县和街道等属性”拿出来
构成一个“地址属性集合”，这个集合就是值对象了。


### 值对象的数据库形态
在领域建模时，我们可以将
部分对象设计为值对象，保留对象的业务涵义，同时又减少了实体的数量；在数据建模时，
我们可以将值对象嵌入实体，减少实体表的数量，简化数据库设计。

### 领域模型和数据模型
DDD 提倡从领域模型设计出发，而不是先设计数据模型。前面讲过了，传统的数据模型设
计通常是一个表对应一个实体，一个主表关联多个从表，当实体表太多的时候就很容易陷入
无穷无尽的复杂的数据库设计，领域模型就很容易被数据模型绑架。可以说，值对象的诞
生，在一定程度上，和实体是互补的。


### 习聚合和聚合根
领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它
用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。

### 怎样设计聚合
第 1 步：采用事件风暴，根据业务行为，梳理出在投保过程中发生这些行为的所有的实体
和值对象，比如投保单、标的、客户、被保人等等。
第 2 步：从众多实体中选出适合作为对象管理者的根实体，也就是聚合根。判断一个实体
是否是聚合根，你可以结合以下场景分析：是否有独立的生命周期？是否有全局唯一 ID？
是否可以创建或修改其它对象？是否有专门的模块来管这个实体。图中的聚合根分别是投保
单和客户实体。
第 3 步：根据业务单一职责和高内聚原则，找出与聚合根关联的所有紧密依赖的实体和值
对象。构建出 1 个包含聚合根（唯一）、多个实体和值对象的对象集合，这个集合就是聚
合。在图中我们构建了客户和投保这两个聚合。
第 4 步：在聚合内根据聚合根、实体和值对象的依赖关系，画出对象的引用和依赖模型。
这里我需要说明一下：投保人和被保人的数据，是通过关联客户 ID 从客户聚合中获取的，
在投保聚合里它们是投保单的值对象，这些值对象的数据是客户的冗余数据，即使未来客户
聚合的数据发生了变更，也不会影响投保单的值对象数据。从图中我们还可以看出实体之间
的引用关系，比如在投保聚合里投保单聚合根引用了报价单实体，报价单实体则引用了报价
规则子实体。
第 5 步：多个聚合根据业务语义和上下文一起划分到同一个限界上下文内。
这就是一个聚合诞生的完整过程了。

### 聚合的一些设计原则
1. 在一致性边界内建模真正的不变条件。聚合用来封装真正的不变性，而不是简单地将对
象组合在一起。聚合内有一套不变的业务规则，各实体和值对象按照统一的业务规则运行，
实现对象数据的一致性，边界之外的任何东西都与该聚合无关，这就是聚合能实现业务高内
聚的原因。
2. 设计小聚合。如果聚合设计得过大，聚合会因为包含过多的实体，导致实体之间的管理
过于复杂，高频操作时会出现并发冲突或者数据库锁，最终导致系统可用性变差。而小聚合
设计则可以降低由于业务过大导致聚合重构的可能性，让领域模型更能适应业务的变化。
3. 通过唯一标识引用其它聚合。聚合之间是通过关联外部聚合根 ID 的方式引用，而不是直
接对象引用的方式。外部聚合的对象放在聚合边界内管理，容易导致聚合的边界不清晰，也
会增加聚合之间的耦合度。
4. 在边界之外使用最终一致性。聚合内数据强一致性，而聚合之间数据最终一致性。在一
次事务中，最多只能更改一个聚合的状态。如果一次业务操作涉及多个聚合状态的更改，应
采用领域事件的方式异步修改相关的聚合，实现聚合之间的解耦（相关内容我会在领域事件
部分详解）。
5. 通过应用层实现跨聚合的服务调用。为实现微服务内聚合之间的解耦，以及未来以聚合
为单位的微服务组合和拆分，应避免跨聚合的领域服务调用和跨聚合的数据库表关联。
上面的这些原则是 DDD 的一些通用的设计原则，还是那句话：“适合自己的才是最好
的。”在系统设计过程时，你一定要考虑项目的具体情况，如果面临使用的便利性、高性能
要求、技术能力缺失和全局事务管理等影响因素，这些原则也并不是不能突破的，总之一切
以解决实际问题为出发点。
### 作者的一些想法
 1、聚合根主要协调聚合内的实体和值对象，通过引用的方式是从数据的角度来保证数
据的一致性。而领域服务主要是从业务行为，通过实体属性和实体方法来进行业务逻辑的组合和
编排，多个实体协作完成复杂的业务逻辑。
2、客户信息修改后，是不能影响保单中的客户数据的，这个客户数据是跟单数据，不会随着客户
实体数据的变更而变化。举个收货地址的例子，你在维护你个人中心的多个收货地址后，不会修
改已经发货的订单上的地址一样的。除非你提出变更收货地址。
3、一般来说应用层不应该有自己的实体对象，它引用领域层的对象，不实现复杂的业务逻辑。通
过对不同聚合的领域服务组合和编排，实现跨聚合的业务协作。
4、在微服务内只有一个应用层。在微服务内尽量避免聚合之间的直接交互。聚合之间的交互都通
过应用层。如果设计时将某个聚合放在了不合适的限界上下文内，以后在聚合拆分和合并时，由
于聚合之间耦合度低，微服务的演进也就容易的多。



### 总结
1. 聚合的特点：高内聚、低耦合，它是领域模型中最底层的边界，可以作为拆分微服务的最小
单位，但我不建议你对微服务过度拆分。但在对性能有极致要求的场景中，聚合可以独立作
为一个微服务，以满足版本的高频发布和极致的弹性伸缩能力。
一个微服务可以包含多个聚合，聚合之间的边界是微服务内天然的逻辑边界。有了这个逻辑
边界，在微服务架构演进时就可以以聚合为单位进行拆分和组合了，微服务的架构演进也就
不再是一件难事了。
2. 聚合根的特点：聚合根是实体，有实体的特点，具有全局唯一标识，有独立的生命周期。一
个聚合只有一个聚合根，聚合根在聚合内对实体和值对象采用直接对象引用的方式进行组织
和协调，聚合根与聚合根之间通过 ID 关联的方式实现聚合之间的协同。
3. 实体的特点：有 ID 标识，通过 ID 判断相等性，ID 在聚合内唯一即可。状态可变，它依附
于聚合根，其生命周期由聚合根管理。实体一般会持久化，但与数据库持久化对象不一定是
一对一的关系。实体可以引用聚合内的聚合根、实体和值对象。
4. 值对象的特点：无 ID，不可变，无生命周期，用完即扔。值对象之间通过属性值判断相等
性。它的核心本质是值，是一组概念完整的属性组成的集合，用于描述实体的状态和特征。
值对象尽量只引用值对象。
### AKF立方体 - 系统优化的扩展思路
1. X轴：直接水平复制应用进程来扩展系统。
2. Y轴：将功能拆分出来扩展系统。
3. Z轴：基于用户信息扩展系统。




NWR 算法是由鸽巢原理得来的：如果 10 只鸽子放入 9 个鸽巢，那么有 1 个鸽巢内至少有
2 只鸽子，这就是鸽巢原理


NWR 算法提供了一个很棒的读写模型，可以解决上述问题。这里的“NWR”，是指在去
中心化系统中将 1 份数据存放在 N 个节点上，每次操作时，写 W 个节点、读 R 个节点，
只要调整 W、R 与 N 的关系，就能动态地平衡一致性与性能。


鸽巢原理
告诉我们，只要哈希函数输入主键的值范围大于输出索引，出现冲突的概率就一定大于 0；
只要存放元素的数量超过哈希桶的数量，就必然会发生冲突。



如果冗余数据存放在 N 个节点上，且每次写操作成功写入
W 个节点（其他 N - W 个节点将异步地同步数据），而读操作则从 R 个节点中选择并读
出正确的数据，只要确保 W + R > N，同 1 条数据的读、写操作就不能并发执行，这样客
户端就总能读到最新写入的数据。特别是当 W > N/2 时，同 1 条数据的修改必然是顺序执
行的。这样，分布式系统就具备了强一致性，这也是 NWR 算法的由来。
比如，若 N 为 3，那么设置 W 和 R 为 2 时，在保障系统强一致性的同时，还允许 3 个节
点中 1 个节点宕机后，系统仍然可以提供读、写服务，这样的系统具备了很高的可用性。
当然，R 和 W 的数值并不需要一致，如何调整它们，取决于读、写请求数量的比例。比如
当 N 为 5 时，如果系统读多写少时，可以将 W 设为 4，而 R 设为 2，这样读操作的性能
会更好。






DTO是服务器端和客户端进行通 信的一个协议格式。数据传输对象.展示层与服务层之间的数据传输对象。

DDD 其实是面向对象方法论的一个升华。我们回头来看它，无外乎是通过划分领域（聚合根、实体、值对象）、领域行为封装到领域对象（充血模式）、内外交互封装到防腐层、职责封装到对应的模块和分层，从而实现了高内聚低耦合 —— 这也是它最精华的部分。


防腐层，该层主要是将外部系统 DO 转义成本系统 DO，避免外部 DO 一旦发生变化，本系统改动范围过大的情况，收敛影响面。

DO
全称为：Domain Object，领域对象，从现实世界中抽象出的业务实体，一般还包含 ORM 映射

DAO
全称为：Data Access Object，数据访问对象，一般所说的 DAO 层，用于连接数据库与外层之间的桥梁，并持久化数据层对象

BO
全称为：Business Object，业务对象，主要作用是把业务逻辑封装成一个对象，这个对象可以包括一个或多个其它对象，比如一个简历 BO 中有教育经历，工作经历，社会关系等 PO 对象

PO
全称为：Persistant Object，持久化对象，与数据库结构映射的实体，数据库中的一条数据即为一个 BO 对象



软件设计的接口隔离原则：如何对类的调用者隐藏类的公有方法？
使用接口隔离原则，就是定义多个接口，不同调用者依赖不同的接口，只看到自己需要的方法。而实现类则实现这些接口，通过多个接口将类内部不同的方法隔离开来。



里氏替换原则: 子类型必须能够替换掉它们的基类型.通俗点说，就是父类是1-10，子类的范围必须要比1-10的范围更大。
违反里氏替换原则不仅仅发生在设计继承的地方，也可能发生在使用父类和子类的地方，错误的使用方法，也可能导致程序违反里氏替换原则，使子类无法替换父类。


依赖倒置原则
高层模块不应该依赖低层模块，二者都应该依赖抽象。
抽象不应该依赖具体实现，具体实现应该依赖抽象。


1. 开闭原则：软件类、模块应该是对修改关闭的，而对扩展是开放的。通俗地说，就是要
不修改代码就是实现需求的变更。

2. 依赖倒置原则：高层模块不应该依赖低层模块，低层模块也不应该依赖高层模块，他们
应该都依赖抽象，而这个抽象是高层定义的，逻辑上属于高层。
3. 里氏替换原则：所有能够使用父类的地方，应该都可以用它的子类替换。但要注意的
是，能不能替换是要看应用场景的，所以在设计继承的时候就要考虑运行期的场景，而
不是仅仅考虑父类和子类的静态关系。
4. 单一职责原则：一个类应该只有一个引起它变化的原因。实践中，就是类文件尽量不要
太大，最好不要超过一屏。
5. 接口隔离原则：不要强迫调用者依赖他们不需要的方法。方法主要是通过对接口的多重
继承，一个类实现多个接口，不同接口服务不同调用者，不同调用者看到不同方法。




如果你对自己要开发的业务领域没有清晰的定义和边界，没有设计系
统的领域模型，而仅仅跟着所谓的需求不断开发功能，一旦需求来自多个方面，就可能发生
需求冲突，或者随着时间的推移，前后功能也会发生冲突，这时你越是试图弥补这些冲突，
就越是陷入更大的冲突之中。

### 事务脚本模式典
事务脚本模式典型的就是 Controller→Service→Dao 这样的程序设计模式。Controller 封
装用户请求，根据请求参数构造一些数据对象调用 Service，Service 里面包含大量的业务
逻辑代码，完成对数据的处理，期间可能需要通过 Dao 从数据库中获取数据，或者将数据
写入数据库中。



粗暴一点说，当我们在代码中看到 else 或者 switch/case 关键字的时候，基本可以判断违反开闭原则了。

使用模板方法模式实现开闭原则
使用观察者模式实现开闭原则
使用适配器模式实现开闭原则
使用策略模式实现开闭原则

实现开闭原则的关键是抽象。当一个模块依赖的是一个抽象接口的时候，就可以随意对这个
抽象接口进行扩展，这个时候，不需要对现有代码进行任何修改，利用接口的多态性，通过
增加一个新实现该接口的实现类，就能完成需求变更。不同场景进行扩展的方式是不同的，
这时候就会产生不同的设计模式，大部分的设计模式都是用来解决扩展的灵活性问题的。
开闭原则可以说是软件设计原则的原则，是软件设计的核心原则，其他的设计原则更偏向技
术性，具有技术性的指导意义，而开闭原则是方向性的，在软件设计的过程中，应该时刻以
开闭原则指导、审视自己的设计：当需求变更的时候，现在的设计能否不修改代码就可以实
现功能的扩展？如果不是，那么就应该进一步使用其他的设计原则和设计模式去重新设计。

