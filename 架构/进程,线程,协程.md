# 进程

# 线程

# 协程
运行此段代码, 系统启动一个新进程
遇到 go(), 当前进程中生成一个协程
协程中遇到 IO阻塞 (这里是 Co::sleep() 模拟出的 IO等待), 协程让出控制, 进入协程调度队列
进程继续向下执行, 输出 hello main
执行下一个协程, 输出 hello go2
之前的协程准备就绪, 继续执行, 输出 hello go1




运行过程
调用onRequest事件回调函数时，底层会调用C函数coro_create创建一个协程（#1位置），同时保存这个时间点的CPU寄存器状态和ZendVM stack信息。
调用mysql->connect时发生IO操作，底层会调用C函数coro_save保存当前协程的状态，包括Zend VM上下文以及协程描述信息，并调用coro_yield让出程序控制权，当前的请求会挂起（#2位置）
协程让出程序控制权后，会继续进入EventLoop处理其他事件，这时Swoole会继续去处理其他客户端发来的Request
IO事件完成后，MySQL连接成功或失败，底层调用C函数coro_resume恢复对应的协程，恢复ZendVM上下文，继续向下执行PHP代码（#3位置）
mysql->query的执行过程与mysql->connect一致，也会进行一次协程切换调度
所有操作完成后，调用end方法返回结果，并销毁此协程




注：不能将 go 函数放到 try 语句块中，这样就是跨协程捕获异常了。


协程之间可以通过Coroutine对象的origin字段形成一个类似链表的结构；Co::yield()换出当前协程时，会换入origin协程；在A协程种调用Co::resume()恢复B协程时，会换出A协程，换入B协程，同时标记A协程为B的origin协程；




Swoole 的每个 Worker 进程 会存在一个协程调度器来调度协程，协程切换的时机就是遇到 I/O 操作或代码显性切换时，
进程内以单线程的形式运行协程，也就意味着一个进程内同一时间只会有一个协程在运行且切换时机明确，也就无需处理像多线程编程下的各种同步锁的问题。
单个协程内的代码运行仍是串行的g给


桥接模式 - 
jdbc ，实现是数据库驱动，抽象是链接(连接上数据库后的所有操作)

Eloquent - 实现是驱动，抽象(每个数据库写一遍，最后，通过配置选择到具体的那个数据库)





什么Redis单线程却很快，
在没有磁盘IO的情况下单核CPU绑定一块内存效率最高
，Redis把读写操作都放在了CPU和内存的部分，
又减少了多线程上下文 切换的过程，因此Redis即便是单线程也很快，
在现代多核CPU的服务器中，
往往会通过根据绑定Redis进程和CPU提高性能。



多线程是为了同步完成多项任务，
不是为了提高运行效率，
而是为了提高资源使用效率来提高系统的效率。


并发执行机制原理：简单地说就是把一个处理器划分为若干个短的时间片，每个时间片依次轮流地执行处理各个应用程序，
由于一个时间片很短，相对于一个应用程序来说，就好像是处理器在为自己单独服务一样，从而达到多个应用程序在同时进行的效果 [3]  。

多线程就是把操作系统中的这种并发执行机制原理运用在一个程序中，把一个程序划分为若干个子任务，多个子任务并发执行，每一个任务就是一个线程。这就是多线程程序




协程和进程的关系，协程是用户调度的线程。
不同：
1. 协程的调度是用户处理的，线程是系统。
2. 协程遇到io操作才会切换。
3.  Swoole 的协程是单进程单线程模型。
4. 每个协程都是相互独立的，需要创建单独的内存空间 (栈内存),协程退出时会释放申请的 stack 内存。